# 배열 안 객체 비교 후 같은 키의 값이 같은 경우 골라내기.

nestjs로 개발중 한가지 문제를 맞닥뜨렸다.

배열 A와 B가 있고
배열 A와 B는 각자 객체를 갖고 있다.
그리고 A의 객체를 a, B의 객체를 b라고 했을때
나는 a와 b를 비교해서 두 객체가 갖고 있는 동일한 키 'key'의 값이 같을 경우를 골라내고 싶다.
값이 같으면 a객체에 'wishlist'라는 키를 넣고 값으로는 true를 넣어주고 싶었다.

가볍게 머리로 생각해보면 
A를 for문으로 돌리면서 a객체를 받고
그 for문 안에서 B를 마찬가지로 for문을 사용해서 b를 얻어 비교할 수 있겠다.

```
for() {
	for() {
	
	}
}
```
이런 모양으로 생각해볼 수 있을것 같다.
근데 얘는 시간 복잡도가 O(n*m) 인거 같다.
배열 A,B가 커질수록 비례해서 늘어나기 때문이다.

어떻게 하면 좋을까 하다가 chatgpt에게 같은 문제 해결을 물어봤고 최소의 시간복잡도 및 공간복잡도를 요청해봤다.
일단 내가 가진 지식으로는 방법이 나오지 않을 것 같아서 chatgpt를 통해 물어보고 좋은것이면 그것을 들여다보며 이해해보려고 한다.

```
function updateWishlist(arrA, arrB) {
    const mapA = new Map(arrA.map(obj => [obj.key, obj]));

    for (const objB of arrB) {
        const keyB = objB.key;
        if (mapA.has(keyB)) {
            mapA.get(keyB).wishlist = true;
        }
    }
}
```

chatgpt가 위와 같은 답을 줬다.
그리고 O(n+m)이라는 답을 내놨다.

공간복잡도에 대한 설명을 물어봤는데 

> 1. `mapA`를 만드는 데는 O(N)의 시간이 소요됩니다. 여기서 N은 배열 A의 길이입니다.
> 2. 배열 B를 순회하면서 'key'를 검색하는 데 O(M)의 시간이 소요됩니다. 여기서 M은 배열 B의 길이입니다. 

이렇게 답을 줬다.
이녀석은 1차적으로 첫번째 배열을 한번 돌면서 map을 만들었다
그리고 두번째 배열을 따로 돌면서 객체의 키를 사용해 map에서 빠르게 원하는 값을 콕찝어 찾도록 했다.
훌륭하다..

이를 통해서 코드가 어떤구조로 돌아서 시간복잡도를 줄였는지는 이해할 수 있었다.
근데 한가지 추가해야할 문제가 있었다.

여기서 `wishlist = true` 가 추가된 객체들은 배열을 이루어서 클라이언트에 response로 보낼 계획이었다. 그말인 즉슨 내가 처음에 생각했던거는 원래의 배열 안의 객체를 조금 수정해서 그대로 response로 반환하는거였는데...

여기서 chatgpt에 위의 질문을 더했는데
결론은 원본 배열이 변경이 되었을거라는 사실..
왜냐하면 javascript에서 객체는 reference 참조이기 때문이란다.

그게 무슨말이냐면 객체를 가져다 수정하면 원본이 수정된다는것.
해서 추가적으로 뭘 더 해줄게 없이 이대로 쓸 수 있다.

일단 여기까지해서 사용을 해보려고 한다.
그리고 js map에 대한 이해도 해야할 것 같다.

```
const mapA = new Map(arrA.map(obj => [obj.key, obj]));
```

이 코드도 사실 뭔지 몰라서 chatgpt에 물어봤다. 
map은 다른글에 따로 적어보겠다.

###### 결론
1. 두개의 배열을 각자 반복문을 돌리는 형태로 가야한다
2. map을 활용하고 키와 값을 이용하면 원하는 값을 빠르게 찾을 수 있다.
